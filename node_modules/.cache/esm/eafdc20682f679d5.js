let readline,read,chalk,webpack,path,ensureDir,themeKit,browserSync,prod,dev;_82f‍.x([["buildWebpack",()=>buildWebpack],["devBuildWebpack",()=>devBuildWebpack],["watchWebpack",()=>watchWebpack],["makeDir",()=>makeDir],["themeKitWatch",()=>themeKitWatch],["open",()=>open],["deploy",()=>deploy],["startbrowserSync",()=>startbrowserSync]]);_82f‍.w("readline",[["default",["readline"],function(v){readline=v}]]);_82f‍.w("read-yaml",[["default",["read"],function(v){read=v}]]);_82f‍.w("chalk",[["default",["chalk"],function(v){chalk=v}]]);_82f‍.w("webpack",[["default",["webpack"],function(v){webpack=v}]]);_82f‍.w("path",[["default",["path"],function(v){path=v}]]);_82f‍.w("fs-extra",[["ensureDir",["ensureDir"],function(v){ensureDir=v}]]);_82f‍.w("@shopify/themekit",[["default",["themeKit"],function(v){themeKit=v}]]);_82f‍.w("browser-sync",[["default",["browserSync"],function(v){browserSync=v}]]);_82f‍.w("../webpack.prod",[["default",["prod"],function(v){prod=v}]]);_82f‍.w("../webpack.dev",[["default",["dev"],function(v){dev=v}]]);/**
 * Theme commands
 * @desc List of commands used to build, compile, watch, and deploy. Executes webpack
 */













const config = read.sync('config.yml');
const themeID = config.theme.theme_id;
const storeURL = config.theme.store;

const { log } = _82f‍.g.console;

const prodWebpack= webpack(prod);
const devWebpack = webpack(dev);

const PATHS = {
  output: path.resolve(__dirname, '../../dist'),
};

/**
 * Compile command via Webpack
 * @desc Compiles with production environment for webpack
 * @func Checks for errors or warnings before building.
 * @returns Pass or Fail. On pass - build files are generated.
 */
       const buildWebpack = async () => {
  await new Promise((resolve, reject) => {
    log(chalk.bgHex('#6849E3').white('[Webpack JavaScript + Stylesheets]'));
    prodWebpack.run((err, stats) => {
      if (err) {
        _82f‍.g.console.error(err.stack || err);
        if (err.details) {
          _82f‍.g.console.error(err.details);
        }
        reject(err);
        return;
      }

      if (stats.hasErrors()) {
        stats.toJson().errors.forEach((errors) => {
          log(errors);
        })
        log('\n⚠️ ', chalk.bgHex('#E35A49').white('[ERROR: WEBPACK FAILED]\n'))
        reject(err);
        return;
      }
  
      if (stats.hasWarnings()) {
        stats.toJson().warnings.forEach((warning) => {
          log(warning);
        })
        log('\n⚠️ ', chalk.bgHex('#E35A49').white('[WARNING: WEBPACK SUCCEEDED WITH WARNINGS]\n'));
      }

      log('✨', chalk.bgHex('#51A766').white('[Build Complete]'));
      // log(stats.toString({
      //   chunks: false,
      //   cached: false,
      //   children: false,
      //   modules: false,
      //   colors: true,
      // }));
      resolve('done');
      return stats;
    });
  });
};

/**
 * DEV Compile command via Webpack
 * @desc Compiles with production environment for webpack
 * @func Checks for errors or warnings before building.
 * @returns Pass or Fail. On pass - build files are generated.
 */
       const devBuildWebpack = async () => {
  await new Promise((resolve, reject) => {
    log(chalk.bgHex('#6849E3').white('[Webpack JavaScript + Stylesheets]'));
    devWebpack.run((err, stats) => {
      if (err) {
        _82f‍.g.console.error(err.stack || err);
        if (err.details) {
          _82f‍.g.console.error(err.details);
        }
        reject(err);
        return;
      }

      if (stats.hasErrors()) {
        stats.toJson().errors.forEach((errors) => {
          log(errors);
        })
        log('\n⚠️ ', chalk.bgHex('#E35A49').white('[ERROR: WEBPACK FAILED]\n'))
        reject(err);
        return;
      }
  
      if (stats.hasWarnings()) {
        stats.toJson().warnings.forEach((warning) => {
          log(warning);
        })
        log('\n⚠️ ', chalk.bgHex('#E35A49').white('[WARNING: WEBPACK SUCCEEDED WITH WARNINGS]\n'));
      }

      log('✨', chalk.bgHex('#51A766').white('[Dev Build Complete]'));
      // log(stats.toString({
      //   chunks: false,
      //   cached: false,
      //   children: false,
      //   modules: false,
      //   colors: true,
      // }));
      resolve('done');
      return stats;
    });
  });
};

/**
 * Watch command via Webpack
 * @desc Watches with development environment for webpack
 * Aggregate timeout, waits for multiple saves before rebuild
 * @func Checks for errors or warnings before building.
 * @returns Pass or Fail. On pass - build files are generated.
 */
       const watchWebpack = async () => {
  await new Promise((resolve, reject) => {
    log(chalk.bgHex('#6849E3').white('[Watch JavaScript + Stylesheets]'));
    devWebpack.watch({
      aggregateTimeout: 1000,
    }, (err, stats) => {
      if (err) {
        _82f‍.g.console.error(err.stack || err);
        if (err.details) {
          _82f‍.g.console.error(err.details);
        }
        reject(err);
        return err;
      }

      if (stats.hasErrors()) {
        stats.toJson().errors.forEach((errors) => {
          log(errors);
        })
        log('\n⚠️ ', chalk.bgHex('#E35A49').white('[ERROR: WEBPACK FAILED]\n'));
        reject(err);
        return;
      }

      if (stats.hasWarnings()) {
        stats.toJson().warnings.forEach((warning) => {
          log(warning);
        })
        log('\n⚠️ ', chalk.bgHex('#E35A49').white('[WARNING: WEBPACK SUCCEEDED WITH WARNINGS]\n'));
      }

      log('✨', chalk.bgHex('#51A766').white('[Webpack Complete]'));
      resolve('done');
      return;
    });
  });
};

/**
 * Ensure dist exists command
 * @desc If no dist folder is found create one
 */
       const makeDir = () => {
  ensureDir(PATHS.output);
};

/**
 * Watch command via Themekit
 * @desc Establish connection with Shopify store via Watch
 * @func Checks for errors or warnings before building.
 * @returns Pass or Fail. On pass - build files are generated.
 */
       const themeKitWatch = () => {
  log('🛍 ', chalk.bgHex('#3AA8B5').white('[Start Themekit Watch]\n'));
  themeKit
    .command('watch', {
      env: 'theme',
      dir: PATHS.output,
      notify: 'theme.update'
    })
    .catch((err) => {
      _82f‍.g.console.error('Error', err);
    });
};

/**
 * Open command via Themekit
 * @desc Open Shopify Store
 */
       const open = () => {
  themeKit
    .command('open', {
      env: 'theme',
    })
    .catch((err) => {
      _82f‍.g.console.error('Error', err);
    });
};

/**
 * Deploy command via Themekit
 * @desc Deploys to Shopify Store then opens store
 */
       const deploy = async () => {
  const ask =  (query) => {
    const rl = readline.createInterface({
        input: process.stdin,
        output: process.stdout,
    });

    return new Promise(
      (resolve) => {
        process.stdout.write('\x07');
        rl.question(query, (ans) => {
          rl.close();
          resolve(ans);
        })
      }
    );
  };

  const answer = await ask(`\n🚢 ${chalk.bgHex('#6849E3').white(`[Press RETURN to deploy to ${themeID} on ${storeURL}]`)}`);

  log('\n🛍 ', chalk.bgHex('#3AA8B5').white('[Start Themekit Deploy]'));
  log('\n⚠️ ', chalk.bgHex('#E35A49').white('[WARNING: STOPPING DEPLOYMENT CAN RESULT IN FILE LOSS]\n'));
  themeKit
    .command('deploy', {
      env: 'theme',
      dir: `${PATHS.output}`,
    })
    .then(() => {
      log('\n🥳', chalk.bgHex('#51A766').white('[Deploy Complete]\n'));
      open();
    })
    .catch((err) => {
      _82f‍.g.console.error('Error', err);
    });
};

       const startbrowserSync = () => {
  log('🔁', chalk.bgHex('#3AA8B5').white('[Start Browser Sync]\n'));
  browserSync.create().init({
    files: 'theme.update',
    proxy: `https://${storeURL}?preview_theme_id=${themeID}`,
    reloadDelay: 2000,
    middleware: [
      (req, res, next) => {
        // Shopify sites with redirection enabled for custom domains force redirection
        // to that domain. `?_fd=0` prevents that forwarding.
        // ?pb=0 hides the Shopify preview bar
        const prefix = req.url.indexOf('?') > -1 ? '&' : '?';
        const queryStringComponents = ['_fd=0&pb=0'];

        req.url += prefix + queryStringComponents.join('&');
        next();
      }
    ],
    snippetOptions: {
      rule: {
        match: /<head[^>]*>/i,
        fn: (snippet, match) => match + snippet,
      },
    },
  });
};
